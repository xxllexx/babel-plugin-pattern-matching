"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _babelTemplate = require("babel-template");

var _babelTemplate2 = _interopRequireDefault(_babelTemplate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _babelTemplate2.default)("\n  const isObject = (value) => {\n    const type = typeof value;\n    return value != null && (type == 'object' || type == 'function')\n  }\n\n  const curry = fn => {\n    return (function n(..._args) {\n      return function(...args) {\n          return [..._args, ...args].length === fn.length ? fn(..._args, ...args) : n(..._args, ...args)\n        };\n    })()\n  }\n\n    function match (...rules) {\n        return function(...args) {\n            for(let i = 0; i < rules.length; i++) {\n                let res, [callback, ...preds] = [...rules[i]].reverse();\n    \n                if(preds.length === args.length && preds.reverse().every((p, i)=> p(args[i]))) {\n                    return callback(...args)\n                }\n            }\n    \n            return false;\n        }\n    }\n\n  const omitParams = curry((keyArray, obj) => Object.keys(obj).filter(k => !keyArray.includes(k)).reduce((acc, k) => (acc[k] = obj[k], acc),{}));\n\n  const andPredicate = (...predicates) => (...args) => predicates.every(p => p(...args));\n  const keyPredicate = (key, ...predicates) => obj => andPredicate(...predicates)(obj[key]) || false;\n\n  const isEmpty = (obj) => {\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          return false\n        }\n      }\n      return true;\n  }\n\n  const arrayIsEmpty = () => arr => Array.isArray(arr) && !arr.length;\n  const lengthIsEqOrAbove = (length = 1) => arr => Array.isArray(arr) && arr.length >= length;\n\n  const isEmptyObject = () => obj => !Array.isArray(obj) && isObject(obj) && isEmpty(obj);\n\n  const objKeysLengthIsEqOrAbove = (length = 1) => obj => !isEmpty(obj) && lengthIsEqOrAbove(length)(Object.keys(obj));\n\n  const keysExists = (...keys) => obj => {\n    for (let k of keys) {\n      if(isEmpty(obj) || !(k in obj) || !obj.hasOwnProperty(k)) return false\n    }\n\n    return true;\n  }\n\n  const catchAll = () => () => true\n  const isDefined = () => obj => (obj !== void 0)\n  const isFunction = (fn) => fn && {}.toString.call(fn) === '[object Function]';\n  const isValue = val => obj => (isFunction(val) ? val() : val) === obj\n  const isNull = () => obj => obj === null\n  const isUndefined = () => obj => obj === void 0\n  const _isNaN = () => (obj) => isNaN(obj) \n  const _rest = '$$get-rest-params';\n  const _allObj = '$$get-all-object';\n\n  const getLevelArgs = (getter, arg) => {\n    return getter.reduce((res0, key) => {\n      if (!isObject(key)) {\n        let k = [key];\n        if (key !== _rest) {\n          return [...res0, k.filter(_k => _k !== _rest && _k !== _allObj).reduce((ret, val) => ret[val], arg)]\n        } else {\n\n          //console.log(getter);\n          let params = getter.reduce((o, g) => [...o, ...(isObject(g) ? Object.keys(g) : [g])], [])\n                  .filter(_k => _k !== _rest && _k !== _allObj);\n\n          return [\n            ...res0,\n            (Array.isArray(arg) || (typeof arg === 'string')\n              ? arg.slice(params.length)\n              : isObject(arg)\n                ? omitParams(params, arg\n                  ) : false\n              )\n          ].filter(a => !!a)\n        }\n      } else {\n        let m = Object.keys(key).reduce((acc, k) => {\n          return [\n            ...acc,\n            ...getLevelArgs(key[k], arg[k])\n          ]\n        }, [])\n\n        return [...res0, ...m]; \n      }\n      return res0;\n    }, [])  \n  } \n\n  const getArgs = (...getters) => (...args) => (getters.length)\n      ? getters.reduce((acc, g, ind) => {\n        return g.length && (args[ind] !== void 0) ? [\n            ...acc, \n            ...getLevelArgs(g, args[ind])\n          ] : acc;\n      }, [])\n      : args;\n");